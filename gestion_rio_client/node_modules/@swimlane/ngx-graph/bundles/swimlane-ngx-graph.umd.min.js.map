{"version":3,"sources":["../../../../node_modules/tslib/tslib.es6.js","ng://@swimlane/ngx-graph/lib/utils/id.ts","ng://@swimlane/ngx-graph/lib/graph/layouts/dagre.ts","ng://@swimlane/ngx-graph/lib/graph/layouts/dagreCluster.ts","ng://@swimlane/ngx-graph/lib/graph/layouts/dagreNodesOnly.ts","ng://@swimlane/ngx-graph/lib/graph/layouts/d3ForceDirected.ts","ng://@swimlane/ngx-graph/lib/graph/layouts/colaForceDirected.ts","ng://@swimlane/ngx-graph/lib/graph/layouts/layout.service.ts","ng://@swimlane/ngx-graph/lib/graph/graph.component.ts","ng://@swimlane/ngx-graph/lib/graph/mouse-wheel.directive.ts","ng://@swimlane/ngx-graph/lib/graph/graph.module.ts","ng://@swimlane/ngx-graph/lib/ngx-graph.module.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__assign","assign","t","s","i","n","arguments","length","prototype","call","apply","this","__values","o","m","Symbol","iterator","next","value","done","__read","r","e","ar","push","error","__spread","concat","cache","id","newId","Math","random","pow","toString","slice","LEFT_TO_RIGHT","RIGHT_TO_LEFT","TOP_TO_BOTTOM","BOTTOM_TO_TOM","DagreLayout","defaultSettings","orientation","Orientation","marginX","marginY","edgePadding","rankPadding","nodePadding","multigraph","compound","settings","run","graph","createDagreGraph","dagre.layout","dagreGraph","edgeLabels","_edgeLabels","dagreNodeId","dagreNode","this_1","_nodes","node","nodes","find","position","x","y","dimension","width","height","updateEdge","edge","sourceNode","source","targetNode","target","dir","startingPoint","endingPoint","points","dagre.graphlib","Graph","setGraph","rankdir","marginx","marginy","edgesep","ranksep","nodesep","align","acyclicer","ranker","setDefaultEdgeLabel","dagreNodes","map","dagreEdges","edges","l","newLink","_c","tslib_1.__values","_d","setNode","_e","_f","setEdge","DagreClusterLayout","_this","dagreToOutput","clusters","dagreClusters","cluster","childNodeIds","forEach","childNodeId","setParent","_g","_h","_j","toD3Node","maybeNode","toNode","nodeRef","layouts","dagre","dagreCluster","dagreNodesOnly","DagreNodesOnlyLayout","curveDistance","_b","rankAxis","orderAxis","rankDimension","_a","edgeLabelId","matchingEdgeLabel","d3ForceDirected","D3ForceDirectedLayout","force","forceSimulation","forceManyBody","strength","forceCollide","forceLink","distance","outputGraph$","Subject","inputGraph","d3Graph","outputGraph","links","alpha","restart","on","d3GraphToOutputGraph","asObservable","transform","onDragStart","draggingNode","$event","alphaTarget","d3Node","draggingStart","fx","fy","onDrag","onDragEnd","undefined","colaForceDirected","ColaForceDirectedLayout","d3adaptor","d3Dispatch","d3Force","d3Timer","linkDistance","avoidOverlaps","viewDimensions","xOffset","internalGraph","groups","padding","nodeId","findIndex","filter","leaves","sourceNodeIndex","targetNodeIndex","groupLinks","onTickListener","internalGraphToOutputGraph","size","forceModifierFn","start","rayIntersection","bounds","cx","cy","groupLink","foundNode","foundGroup","group","index","inputGroup","nodeIndex","fixed","LayoutService","getLayout","name","Error","Injectable","GraphComponent","el","zone","cd","layoutService","_super","legend","activeEntries","draggingEnabled","panningEnabled","enableZoom","zoomSpeed","minZoomLevel","maxZoomLevel","autoZoom","panOnZoom","animate","autoCenter","activate","EventEmitter","deactivate","zoomChange","graphSubscription","Subscription","subscriptions","margin","results","isPanning","isDragging","initialized","graphDims","_oldLinks","oldNodes","Set","transformationMatrix","identity","_touchLastX","_touchLastY","groupResultsBy","label","__","constructor","create","tslib_1.__extends","defineProperty","a","level","zoomTo","Number","panTo","f","ngOnInit","update$","subscribe","update","center$","center","zoomToFit$","zoomToFit","panToNode$","panToNodeId","ngOnChanges","changes","layout","layoutSettings","setLayout","setLayoutSettings","ngOnDestroy","unsubscribe","ngAfterViewInit","setTimeout","curve","shape.curveBundle","beta","dims","calculateViewDimensions","margins","showLegend","seriesDomain","getSeriesDomain","setColors","legendOptions","getLegendOptions","createGraph","updateTransform","initializeNode","meta","forceDimensions","nodeWidth","nodeHeight","data","tslib_1.__spread","requestAnimationFrame","draw","applyNodeDimensions","result","result$","Observable","of","add","tick","pipe","first","color","colors","getColor","newLinks","edgeLabel","normKey","replace","oldLink","ol","linkFromGraph","nl","JSON","stringify","oldLine","line","generateLine","midPoint","floor","first_1","second","textPos","textTransform","textAngle","calcDominantBaseline","newL","max","redrawLines","markForCheck","nodeElements","elem","nativeElement","getBBox","ex","nodeMaxHeight","nodeMinHeight","min","getElementsByTagName","maxTextDims","currentBBox","nodeMaxWidth","nodeMinWidth","_animate","linkElements","linkEl","lin","select","attr","transition","ease","ease.easeSinInOut","duration","chartElement","oldTextPath","textPath","link","firstPoint","lastPoint","dominantBaseline","reverse","shape\n            .line","lineFunction","onZoom","direction","zoomFactor","newZoomLevel","zoomLevel","mouseX","clientX","mouseY","clientY","svg","chart","querySelector","svgGroup","point","createSVGPoint","svgPoint","matrixTransform","getScreenCTM","inverse","pan","zoom","ignoreZoomLevel","translate","isNaN","panX","panOffsetX","panY","panOffsetY","factor","scale","emit","onPan","event","movementX","movementY","this_2","redrawEdge","toSVG","smoothMatrix","onClick","onActivate","indexOf","entries","onDeactivate","idx","splice","reduce","sort","trackLinkBy","trackNodeBy","ColorHelper","scheme","customColors","scaleType","domain","onMouseMove","onTouchStart","changedTouches","onTouchMove","onTouchEnd","onMouseUp","onNodeMouseDown","heightZoom","widthZoom","Component","args","selector","template","encapsulation","ViewEncapsulation","None","changeDetection","ChangeDetectionStrategy","OnPush","ElementRef","NgZone","ChangeDetectorRef","Input","Output","ContentChild","ViewChild","ChartComponent","read","ViewChildren","HostListener","BaseChartComponent","MouseWheelDirective","mouseWheelUp","mouseWheelDown","onMouseWheelChrome","mouseWheelFunc","onMouseWheelFirefox","onMouseWheelIE","window","delta","wheelDelta","detail","returnValue","preventDefault","Directive","GraphModule","NgModule","imports","ChartCommonModule","declarations","exports","providers","NgxGraphModule","NgxChartsModule"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","const cache = {};\n\n/**\n * Generates a short id.\n *\n */\nexport function id(): string {\n  let newId = ('0000' + ((Math.random() * Math.pow(36, 4)) << 0).toString(36)).slice(-4);\n\n  newId = `a${newId}`;\n\n  // ensure not already used\n  if (!cache[newId]) {\n    cache[newId] = true;\n    return newId;\n  }\n\n  return id();\n}\n","import { Layout } from '../../models/layout.model';\nimport { Graph } from '../../models/graph.model';\nimport { id } from '../../utils/id';\nimport * as dagre from 'dagre';\nimport { Edge } from '../../models/edge.model';\n\nexport enum Orientation {\n  LEFT_TO_RIGHT = 'LR',\n  RIGHT_TO_LEFT = 'RL',\n  TOP_TO_BOTTOM = 'TB',\n  BOTTOM_TO_TOM = 'BT'\n}\nexport enum Alignment {\n  CENTER = 'C',\n  UP_LEFT = 'UL',\n  UP_RIGHT = 'UR',\n  DOWN_LEFT = 'DL',\n  DOWN_RIGHT = 'DR'\n}\n\nexport interface DagreSettings {\n  orientation?: Orientation;\n  marginX?: number;\n  marginY?: number;\n  edgePadding?: number;\n  rankPadding?: number;\n  nodePadding?: number;\n  align?: Alignment;\n  acyclicer?: 'greedy' | undefined;\n  ranker?: 'network-simplex' | 'tight-tree' | 'longest-path';\n  multigraph?: boolean;\n  compound?: boolean;\n}\n\nexport class DagreLayout implements Layout {\n  defaultSettings: DagreSettings = {\n    orientation: Orientation.LEFT_TO_RIGHT,\n    marginX: 20,\n    marginY: 20,\n    edgePadding: 100,\n    rankPadding: 100,\n    nodePadding: 50,\n    multigraph: true,\n    compound: true\n  };\n  settings: DagreSettings = {};\n\n  dagreGraph: any;\n  dagreNodes: any;\n  dagreEdges: any;\n\n  run(graph: Graph): Graph {\n    this.createDagreGraph(graph);\n    dagre.layout(this.dagreGraph);\n\n    graph.edgeLabels = this.dagreGraph._edgeLabels;\n\n    for (const dagreNodeId in this.dagreGraph._nodes) {\n      const dagreNode = this.dagreGraph._nodes[dagreNodeId];\n      const node = graph.nodes.find(n => n.id === dagreNode.id);\n      node.position = {\n        x: dagreNode.x,\n        y: dagreNode.y\n      };\n      node.dimension = {\n        width: dagreNode.width,\n        height: dagreNode.height\n      };\n    }\n\n    return graph;\n  }\n\n  updateEdge(graph: Graph, edge: Edge): Graph {\n    const sourceNode = graph.nodes.find(n => n.id === edge.source);\n    const targetNode = graph.nodes.find(n => n.id === edge.target);\n\n    // determine new arrow position\n    const dir = sourceNode.position.y <= targetNode.position.y ? -1 : 1;\n    const startingPoint = {\n      x: sourceNode.position.x,\n      y: sourceNode.position.y - dir * (sourceNode.dimension.height / 2)\n    };\n    const endingPoint = {\n      x: targetNode.position.x,\n      y: targetNode.position.y + dir * (targetNode.dimension.height / 2)\n    };\n\n    // generate new points\n    edge.points = [startingPoint, endingPoint];\n    return graph;\n  }\n\n  createDagreGraph(graph: Graph): any {\n    const settings = Object.assign({}, this.defaultSettings, this.settings);\n    this.dagreGraph = new dagre.graphlib.Graph({compound: settings.compound, multigraph: settings.multigraph});\n    \n    this.dagreGraph.setGraph({\n      rankdir: settings.orientation,\n      marginx: settings.marginX,\n      marginy: settings.marginY,\n      edgesep: settings.edgePadding,\n      ranksep: settings.rankPadding,\n      nodesep: settings.nodePadding,\n      align: settings.align,\n      acyclicer: settings.acyclicer,\n      ranker: settings.ranker,\n      multigraph: settings.multigraph,\n      compound: settings.compound\n    });\n\n    // Default to assigning a new object as a label for each new edge.\n    this.dagreGraph.setDefaultEdgeLabel(() => {\n      return {\n        /* empty */\n      };\n    });\n\n    this.dagreNodes = graph.nodes.map(n => {\n      const node: any = Object.assign({}, n);\n      node.width = n.dimension.width;\n      node.height = n.dimension.height;\n      node.x = n.position.x;\n      node.y = n.position.y;\n      return node;\n    });\n\n    this.dagreEdges = graph.edges.map(l => {\n      const newLink: any = Object.assign({}, l);\n      if (!newLink.id) {\n        newLink.id = id();\n      }\n      return newLink;\n    });\n\n    for (const node of this.dagreNodes) {\n      if (!node.width) {\n        node.width = 20;\n      }\n      if (!node.height) {\n        node.height = 30;\n      }\n\n      // update dagre\n      this.dagreGraph.setNode(node.id, node);\n    }\n\n    // update dagre\n    for (const edge of this.dagreEdges) {\n      if (settings.multigraph) {\n        this.dagreGraph.setEdge(edge.source, edge.target, edge, edge.id);\n      } else {\n        this.dagreGraph.setEdge(edge.source, edge.target);\n      }\n    }\n\n    return this.dagreGraph;\n  }\n}\n","import { Layout } from '../../models/layout.model';\nimport { Graph } from '../../models/graph.model';\nimport { id } from '../../utils/id';\nimport * as dagre from 'dagre';\nimport { Edge } from '../../models/edge.model';\nimport { Node, ClusterNode } from '../../models/node.model';\nimport { DagreSettings, Orientation } from './dagre';\n\nexport class DagreClusterLayout implements Layout {\n  defaultSettings: DagreSettings = {\n    orientation: Orientation.LEFT_TO_RIGHT,\n    marginX: 20,\n    marginY: 20,\n    edgePadding: 100,\n    rankPadding: 100,\n    nodePadding: 50,\n    multigraph: true,\n    compound: true\n  };\n  settings: DagreSettings = {};\n\n  dagreGraph: any;\n  dagreNodes: Node[];\n  dagreClusters: ClusterNode[];\n  dagreEdges: any;\n\n  run(graph: Graph): Graph {\n    this.createDagreGraph(graph);\n    dagre.layout(this.dagreGraph);\n\n    graph.edgeLabels = this.dagreGraph._edgeLabels;\n\n    const dagreToOutput = node => {\n      const dagreNode = this.dagreGraph._nodes[node.id];\n      return {\n        ...node,\n        position: {\n          x: dagreNode.x,\n          y: dagreNode.y\n        },\n        dimension: {\n          width: dagreNode.width,\n          height: dagreNode.height\n        }\n      };\n    };\n    graph.clusters = (graph.clusters || []).map(dagreToOutput);\n    graph.nodes = graph.nodes.map(dagreToOutput);\n\n    return graph;\n  }\n\n  updateEdge(graph: Graph, edge: Edge): Graph {\n    const sourceNode = graph.nodes.find(n => n.id === edge.source);\n    const targetNode = graph.nodes.find(n => n.id === edge.target);\n\n    // determine new arrow position\n    const dir = sourceNode.position.y <= targetNode.position.y ? -1 : 1;\n    const startingPoint = {\n      x: sourceNode.position.x,\n      y: sourceNode.position.y - dir * (sourceNode.dimension.height / 2)\n    };\n    const endingPoint = {\n      x: targetNode.position.x,\n      y: targetNode.position.y + dir * (targetNode.dimension.height / 2)\n    };\n\n    // generate new points\n    edge.points = [startingPoint, endingPoint];\n    return graph;\n  }\n\n  createDagreGraph(graph: Graph): any {\n    const settings = Object.assign({}, this.defaultSettings, this.settings);\n    this.dagreGraph = new dagre.graphlib.Graph({ compound: settings.compound, multigraph: settings.multigraph });\n    this.dagreGraph.setGraph({\n      rankdir: settings.orientation,\n      marginx: settings.marginX,\n      marginy: settings.marginY,\n      edgesep: settings.edgePadding,\n      ranksep: settings.rankPadding,\n      nodesep: settings.nodePadding,\n      align: settings.align,\n      acyclicer: settings.acyclicer,\n      ranker: settings.ranker,\n      multigraph: settings.multigraph,\n      compound: settings.compound\n    });\n\n    // Default to assigning a new object as a label for each new edge.\n    this.dagreGraph.setDefaultEdgeLabel(() => {\n      return {\n        /* empty */\n      };\n    });\n\n    this.dagreNodes = graph.nodes.map((n: Node) => {\n      const node: any = Object.assign({}, n);\n      node.width = n.dimension.width;\n      node.height = n.dimension.height;\n      node.x = n.position.x;\n      node.y = n.position.y;\n      return node;\n    });\n\n    this.dagreClusters = graph.clusters || [];\n\n    this.dagreEdges = graph.edges.map(l => {\n      const newLink: any = Object.assign({}, l);\n      if (!newLink.id) {\n        newLink.id = id();\n      }\n      return newLink;\n    });\n\n    for (const node of this.dagreNodes) {\n      this.dagreGraph.setNode(node.id, node);\n    }\n\n    for (const cluster of this.dagreClusters) {\n      this.dagreGraph.setNode(cluster.id, cluster);\n      cluster.childNodeIds.forEach(childNodeId => {\n        this.dagreGraph.setParent(childNodeId, cluster.id);\n      });\n    }\n\n    // update dagre\n    for (const edge of this.dagreEdges) {\n      if (settings.multigraph) {\n        this.dagreGraph.setEdge(edge.source, edge.target, edge, edge.id);\n      } else {\n        this.dagreGraph.setEdge(edge.source, edge.target);\n      }\n    }\n\n    return this.dagreGraph;\n  }\n}\n","import { Layout } from '../../models/layout.model';\nimport { Graph } from '../../models/graph.model';\nimport { id } from '../../utils/id';\nimport * as dagre from 'dagre';\nimport { Edge } from '../../models/edge.model';\n\nexport enum Orientation {\n  LEFT_TO_RIGHT = 'LR',\n  RIGHT_TO_LEFT = 'RL',\n  TOP_TO_BOTTOM = 'TB',\n  BOTTOM_TO_TOM = 'BT'\n}\nexport enum Alignment {\n  CENTER = 'C',\n  UP_LEFT = 'UL',\n  UP_RIGHT = 'UR',\n  DOWN_LEFT = 'DL',\n  DOWN_RIGHT = 'DR'\n}\n\nexport interface DagreSettings {\n  orientation?: Orientation;\n  marginX?: number;\n  marginY?: number;\n  edgePadding?: number;\n  rankPadding?: number;\n  nodePadding?: number;\n  align?: Alignment;\n  acyclicer?: 'greedy' | undefined;\n  ranker?: 'network-simplex' | 'tight-tree' | 'longest-path';\n  multigraph?: boolean;\n  compound?: boolean;\n}\n\nexport interface DagreNodesOnlySettings extends DagreSettings {\n  curveDistance?: number;\n}\n\nconst DEFAULT_EDGE_NAME = '\\x00';\nconst GRAPH_NODE = '\\x00';\nconst EDGE_KEY_DELIM = '\\x01';\n\nexport class DagreNodesOnlyLayout implements Layout {\n  defaultSettings: DagreNodesOnlySettings = {\n    orientation: Orientation.LEFT_TO_RIGHT,\n    marginX: 20,\n    marginY: 20,\n    edgePadding: 100,\n    rankPadding: 100,\n    nodePadding: 50,\n    curveDistance: 20,\n    multigraph: true,\n    compound: true\n  };\n  settings: DagreNodesOnlySettings = {};\n\n  dagreGraph: any;\n  dagreNodes: any;\n  dagreEdges: any;\n\n  run(graph: Graph): Graph {\n    this.createDagreGraph(graph);\n    dagre.layout(this.dagreGraph);\n\n    graph.edgeLabels = this.dagreGraph._edgeLabels;\n\n    for (const dagreNodeId in this.dagreGraph._nodes) {\n      const dagreNode = this.dagreGraph._nodes[dagreNodeId];\n      const node = graph.nodes.find(n => n.id === dagreNode.id);\n      node.position = {\n        x: dagreNode.x,\n        y: dagreNode.y\n      };\n      node.dimension = {\n        width: dagreNode.width,\n        height: dagreNode.height\n      };\n    }\n    for (const edge of graph.edges) {\n      this.updateEdge(graph, edge);\n    }\n\n    return graph;\n  }\n\n  updateEdge(graph: Graph, edge: Edge): Graph {\n    const sourceNode = graph.nodes.find(n => n.id === edge.source);\n    const targetNode = graph.nodes.find(n => n.id === edge.target);\n    const rankAxis: 'x' | 'y' = this.settings.orientation === 'BT' || this.settings.orientation === 'TB' ? 'y' : 'x';\n    const orderAxis: 'x' | 'y' = rankAxis === 'y' ? 'x' : 'y';\n    const rankDimension = rankAxis === 'y' ? 'height' : 'width';\n    // determine new arrow position\n    const dir = sourceNode.position[rankAxis] <= targetNode.position[rankAxis] ? -1 : 1;\n    const startingPoint = {\n      [orderAxis]: sourceNode.position[orderAxis],\n      [rankAxis]: sourceNode.position[rankAxis] - dir * (sourceNode.dimension[rankDimension] / 2)\n    };\n    const endingPoint = {\n      [orderAxis]: targetNode.position[orderAxis],\n      [rankAxis]: targetNode.position[rankAxis] + dir * (targetNode.dimension[rankDimension] / 2)\n    };\n\n    const curveDistance = this.settings.curveDistance || this.defaultSettings.curveDistance;\n    // generate new points\n    edge.points = [\n      startingPoint,\n      {\n        [orderAxis]: startingPoint[orderAxis],\n        [rankAxis]: startingPoint[rankAxis] - dir * curveDistance\n      },\n      {\n        [orderAxis]: endingPoint[orderAxis],\n        [rankAxis]: endingPoint[rankAxis] + dir * curveDistance\n      },\n      endingPoint\n    ];\n    const edgeLabelId = `${edge.source}${EDGE_KEY_DELIM}${edge.target}${EDGE_KEY_DELIM}${DEFAULT_EDGE_NAME}`;\n    const matchingEdgeLabel = graph.edgeLabels[edgeLabelId];\n    if (matchingEdgeLabel) {\n      matchingEdgeLabel.points = edge.points;\n    }\n    return graph;\n  }\n\n  createDagreGraph(graph: Graph): any {\n    const settings = Object.assign({}, this.defaultSettings, this.settings);\n    this.dagreGraph = new dagre.graphlib.Graph({ compound: settings.compound, multigraph: settings.multigraph });\n    this.dagreGraph.setGraph({\n      rankdir: settings.orientation,\n      marginx: settings.marginX,\n      marginy: settings.marginY,\n      edgesep: settings.edgePadding,\n      ranksep: settings.rankPadding,\n      nodesep: settings.nodePadding,\n      align: settings.align,\n      acyclicer: settings.acyclicer,\n      ranker: settings.ranker,\n      multigraph: settings.multigraph,\n      compound: settings.compound\n    });\n\n    // Default to assigning a new object as a label for each new edge.\n    this.dagreGraph.setDefaultEdgeLabel(() => {\n      return {\n        /* empty */\n      };\n    });\n\n    this.dagreNodes = graph.nodes.map(n => {\n      const node: any = Object.assign({}, n);\n      node.width = n.dimension.width;\n      node.height = n.dimension.height;\n      node.x = n.position.x;\n      node.y = n.position.y;\n      return node;\n    });\n\n    this.dagreEdges = graph.edges.map(l => {\n      const newLink: any = Object.assign({}, l);\n      if (!newLink.id) {\n        newLink.id = id();\n      }\n      return newLink;\n    });\n\n    for (const node of this.dagreNodes) {\n      if (!node.width) {\n        node.width = 20;\n      }\n      if (!node.height) {\n        node.height = 30;\n      }\n\n      // update dagre\n      this.dagreGraph.setNode(node.id, node);\n    }\n\n    // update dagre\n    for (const edge of this.dagreEdges) {\n      if (settings.multigraph) {\n        this.dagreGraph.setEdge(edge.source, edge.target, edge, edge.id);\n      } else {\n        this.dagreGraph.setEdge(edge.source, edge.target);\n      }\n    }\n\n    return this.dagreGraph;\n  }\n}\n","import { Layout } from '../../models/layout.model';\nimport { Graph } from '../../models/graph.model';\nimport { Node } from '../../models/node.model';\nimport { id } from '../../utils/id';\nimport { forceCollide, forceLink, forceManyBody, forceSimulation } from 'd3-force';\nimport { Edge } from '../../models/edge.model';\nimport { Observable, Subject } from 'rxjs';\nimport { NodePosition } from '../../models';\n\nexport interface D3ForceDirectedSettings {\n  force?: any;\n  forceLink?: any;\n}\nexport interface D3Node {\n  id?: string;\n  x: number;\n  y: number;\n  width?: number;\n  height?: number;\n  fx?: number;\n  fy?: number;\n}\nexport interface D3Edge {\n  source: string | D3Node;\n  target: string | D3Node;\n  midPoint: NodePosition;\n}\nexport interface D3Graph {\n  nodes: D3Node[];\n  edges: D3Edge[];\n}\nexport interface MergedNode extends D3Node, Node {\n  id: string;\n}\n\nexport function toD3Node(maybeNode: string | D3Node): D3Node {\n  if (typeof maybeNode === 'string') {\n    return {\n      id: maybeNode,\n      x: 0,\n      y: 0\n    };\n  }\n  return maybeNode;\n}\n\nexport class D3ForceDirectedLayout implements Layout {\n  defaultSettings: D3ForceDirectedSettings = {\n    force: forceSimulation<any>()\n      .force('charge', forceManyBody().strength(-150))\n      .force('collide', forceCollide(5)),\n    forceLink: forceLink<any, any>()\n      .id(node => node.id)\n      .distance(() => 100)\n  };\n  settings: D3ForceDirectedSettings = {};\n\n  inputGraph: Graph;\n  outputGraph: Graph;\n  d3Graph: D3Graph;\n  outputGraph$: Subject<Graph> = new Subject();\n\n  draggingStart: { x: number; y: number };\n\n  run(graph: Graph): Observable<Graph> {\n    this.inputGraph = graph;\n    this.d3Graph = {\n      nodes: [...this.inputGraph.nodes.map(n => ({ ...n }))] as any,\n      edges: [...this.inputGraph.edges.map(e => ({ ...e }))] as any\n    };\n    this.outputGraph = {\n      nodes: [],\n      edges: [],\n      edgeLabels: []\n    };\n    this.outputGraph$.next(this.outputGraph);\n    this.settings = Object.assign({}, this.defaultSettings, this.settings);\n    if (this.settings.force) {\n      this.settings.force\n        .nodes(this.d3Graph.nodes)\n        .force('link', this.settings.forceLink.links(this.d3Graph.edges))\n        .alpha(0.5)\n        .restart()\n        .on('tick', () => {\n          this.outputGraph$.next(this.d3GraphToOutputGraph(this.d3Graph));\n        });\n    }\n\n    return this.outputGraph$.asObservable();\n  }\n\n  updateEdge(graph: Graph, edge: Edge): Observable<Graph> {\n    const settings = Object.assign({}, this.defaultSettings, this.settings);\n    if (settings.force) {\n      settings.force\n        .nodes(this.d3Graph.nodes)\n        .force('link', settings.forceLink.links(this.d3Graph.edges))\n        .alpha(0.5)\n        .restart()\n        .on('tick', () => {\n          this.outputGraph$.next(this.d3GraphToOutputGraph(this.d3Graph));\n        });\n    }\n\n    return this.outputGraph$.asObservable();\n  }\n\n  d3GraphToOutputGraph(d3Graph: D3Graph): Graph {\n    this.outputGraph.nodes = this.d3Graph.nodes.map((node: MergedNode) => ({\n      ...node,\n      id: node.id || id(),\n      position: {\n        x: node.x,\n        y: node.y\n      },\n      dimension: {\n        width: (node.dimension && node.dimension.width) || 20,\n        height: (node.dimension && node.dimension.height) || 20\n      },\n      transform: `translate(${node.x - ((node.dimension && node.dimension.width) || 20) / 2 || 0}, ${node.y -\n        ((node.dimension && node.dimension.height) || 20) / 2 || 0})`\n    }));\n\n    this.outputGraph.edges = this.d3Graph.edges.map(edge => ({\n      ...edge,\n      source: toD3Node(edge.source).id,\n      target: toD3Node(edge.target).id,\n      points: [\n        {\n          x: toD3Node(edge.source).x,\n          y: toD3Node(edge.source).y\n        },\n        {\n          x: toD3Node(edge.target).x,\n          y: toD3Node(edge.target).y\n        }\n      ]\n    }));\n\n    this.outputGraph.edgeLabels = this.outputGraph.edges;\n    return this.outputGraph;\n  }\n\n  onDragStart(draggingNode: Node, $event: MouseEvent): void {\n    this.settings.force.alphaTarget(0.3).restart();\n    const node = this.d3Graph.nodes.find(d3Node => d3Node.id === draggingNode.id);\n    if (!node) {\n      return;\n    }\n    this.draggingStart = { x: $event.x - node.x, y: $event.y - node.y };\n    node.fx = $event.x - this.draggingStart.x;\n    node.fy = $event.y - this.draggingStart.y;\n  }\n\n  onDrag(draggingNode: Node, $event: MouseEvent): void {\n    if (!draggingNode) {\n      return;\n    }\n    const node = this.d3Graph.nodes.find(d3Node => d3Node.id === draggingNode.id);\n    if (!node) {\n      return;\n    }\n    node.fx = $event.x - this.draggingStart.x;\n    node.fy = $event.y - this.draggingStart.y;\n  }\n\n  onDragEnd(draggingNode: Node, $event: MouseEvent): void {\n    if (!draggingNode) {\n      return;\n    }\n    const node = this.d3Graph.nodes.find(d3Node => d3Node.id === draggingNode.id);\n    if (!node) {\n      return;\n    }\n\n    this.settings.force.alphaTarget(0);\n    node.fx = undefined;\n    node.fy = undefined;\n  }\n}\n","import { Layout } from '../../models/layout.model';\nimport { Graph } from '../../models/graph.model';\nimport { Node, ClusterNode } from '../../models/node.model';\nimport { id } from '../../utils/id';\nimport { d3adaptor, ID3StyleLayoutAdaptor, Layout as ColaLayout, Group, InputNode, Link, Rectangle } from 'webcola';\nimport * as d3Dispatch from 'd3-dispatch';\nimport * as d3Force from 'd3-force';\nimport * as d3Timer from 'd3-timer';\nimport { Edge } from '../../models/edge.model';\nimport { Observable, Subject } from 'rxjs';\nimport { ViewDimensions } from '@swimlane/ngx-charts';\n\nexport interface ColaForceDirectedSettings {\n  force?: ColaLayout & ID3StyleLayoutAdaptor;\n  forceModifierFn?: (force: ColaLayout & ID3StyleLayoutAdaptor) => ColaLayout & ID3StyleLayoutAdaptor;\n  onTickListener?: (internalGraph: ColaGraph) => void;\n  viewDimensions?: ViewDimensions;\n}\nexport interface ColaGraph {\n  groups: Group[];\n  nodes: InputNode[];\n  links: Array<Link<number>>;\n}\nexport function toNode(nodes: InputNode[], nodeRef: InputNode | number): InputNode {\n  if (typeof nodeRef === 'number') {\n    return nodes[nodeRef];\n  }\n  return nodeRef;\n}\n\nexport class ColaForceDirectedLayout implements Layout {\n  defaultSettings: ColaForceDirectedSettings = {\n    force: d3adaptor({\n      ...d3Dispatch,\n      ...d3Force,\n      ...d3Timer\n    })\n      .linkDistance(150)\n      .avoidOverlaps(true),\n    viewDimensions: {\n      width: 600,\n      height: 600,\n      xOffset: 0\n    }\n  };\n  settings: ColaForceDirectedSettings = {};\n\n  inputGraph: Graph;\n  outputGraph: Graph;\n  internalGraph: ColaGraph & { groupLinks?: Edge[] };\n  outputGraph$: Subject<Graph> = new Subject();\n\n  draggingStart: { x: number; y: number };\n\n  run(graph: Graph): Observable<Graph> {\n    this.inputGraph = graph;\n    if (!this.inputGraph.clusters) {\n      this.inputGraph.clusters = [];\n    }\n    this.internalGraph = {\n      nodes: [\n        ...this.inputGraph.nodes.map(n => ({\n          ...n,\n          width: n.dimension ? n.dimension.width : 20,\n          height: n.dimension ? n.dimension.height : 20\n        }))\n      ] as any,\n      groups: [\n        ...this.inputGraph.clusters.map(\n          (cluster): Group => ({\n            padding: 5,\n            groups: cluster.childNodeIds\n              .map(nodeId => <any>this.inputGraph.clusters.findIndex(node => node.id === nodeId))\n              .filter(x => x >= 0),\n            leaves: cluster.childNodeIds\n              .map(nodeId => <any>this.inputGraph.nodes.findIndex(node => node.id === nodeId))\n              .filter(x => x >= 0)\n          })\n        )\n      ],\n      links: [\n        ...this.inputGraph.edges\n          .map(e => {\n            const sourceNodeIndex = this.inputGraph.nodes.findIndex(node => e.source === node.id);\n            const targetNodeIndex = this.inputGraph.nodes.findIndex(node => e.target === node.id);\n            if (sourceNodeIndex === -1 || targetNodeIndex === -1) {\n              return undefined;\n            }\n            return {\n              ...e,\n              source: sourceNodeIndex,\n              target: targetNodeIndex\n            };\n          })\n          .filter(x => !!x)\n      ] as any,\n      groupLinks: [\n        ...this.inputGraph.edges\n          .map(e => {\n            const sourceNodeIndex = this.inputGraph.nodes.findIndex(node => e.source === node.id);\n            const targetNodeIndex = this.inputGraph.nodes.findIndex(node => e.target === node.id);\n            if (sourceNodeIndex >= 0 && targetNodeIndex >= 0) {\n              return undefined;\n            }\n            return e;\n          })\n          .filter(x => !!x)\n      ]\n    };\n    this.outputGraph = {\n      nodes: [],\n      clusters: [],\n      edges: [],\n      edgeLabels: []\n    };\n    this.outputGraph$.next(this.outputGraph);\n    this.settings = Object.assign({}, this.defaultSettings, this.settings);\n    if (this.settings.force) {\n      this.settings.force = this.settings.force\n        .nodes(this.internalGraph.nodes)\n        .groups(this.internalGraph.groups)\n        .links(this.internalGraph.links)\n        .alpha(0.5)\n        .on('tick', () => {\n          if (this.settings.onTickListener) {\n            this.settings.onTickListener(this.internalGraph);\n          }\n          this.outputGraph$.next(this.internalGraphToOutputGraph(this.internalGraph));\n        });\n      if (this.settings.viewDimensions) {\n        this.settings.force = this.settings.force.size([\n          this.settings.viewDimensions.width,\n          this.settings.viewDimensions.height\n        ]);\n      }\n      if (this.settings.forceModifierFn) {\n        this.settings.force = this.settings.forceModifierFn(this.settings.force);\n      }\n      this.settings.force.start();\n    }\n\n    return this.outputGraph$.asObservable();\n  }\n\n  updateEdge(graph: Graph, edge: Edge): Observable<Graph> {\n    const settings = Object.assign({}, this.defaultSettings, this.settings);\n    if (settings.force) {\n      settings.force.start();\n    }\n\n    return this.outputGraph$.asObservable();\n  }\n\n  internalGraphToOutputGraph(internalGraph: any): Graph {\n    this.outputGraph.nodes = internalGraph.nodes.map(node => ({\n      ...node,\n      id: node.id || id(),\n      position: {\n        x: node.x,\n        y: node.y\n      },\n      dimension: {\n        width: (node.dimension && node.dimension.width) || 20,\n        height: (node.dimension && node.dimension.height) || 20\n      },\n      transform: `translate(${node.x - ((node.dimension && node.dimension.width) || 20) / 2 || 0}, ${node.y -\n        ((node.dimension && node.dimension.height) || 20) / 2 || 0})`\n    }));\n\n    this.outputGraph.edges = internalGraph.links\n      .map(edge => {\n        const source: any = toNode(internalGraph.nodes, edge.source);\n        const target: any = toNode(internalGraph.nodes, edge.target);\n        return {\n          ...edge,\n          source: source.id,\n          target: target.id,\n          points: [\n            (source.bounds as Rectangle).rayIntersection(target.bounds.cx(), target.bounds.cy()),\n            (target.bounds as Rectangle).rayIntersection(source.bounds.cx(), source.bounds.cy())\n          ]\n        };\n      })\n      .concat(\n        internalGraph.groupLinks.map(groupLink => {\n          const sourceNode = internalGraph.nodes.find(foundNode => (foundNode as any).id === groupLink.source);\n          const targetNode = internalGraph.nodes.find(foundNode => (foundNode as any).id === groupLink.target);\n          const source =\n            sourceNode || internalGraph.groups.find(foundGroup => (foundGroup as any).id === groupLink.source);\n          const target =\n            targetNode || internalGraph.groups.find(foundGroup => (foundGroup as any).id === groupLink.target);\n          return {\n            ...groupLink,\n            source: source.id,\n            target: target.id,\n            points: [\n              (source.bounds as Rectangle).rayIntersection(target.bounds.cx(), target.bounds.cy()),\n              (target.bounds as Rectangle).rayIntersection(source.bounds.cx(), source.bounds.cy())\n            ]\n          };\n        })\n      );\n\n    this.outputGraph.clusters = internalGraph.groups.map(\n      (group, index): ClusterNode => {\n        const inputGroup = this.inputGraph.clusters[index];\n        return {\n          ...inputGroup,\n          dimension: {\n            width: group.bounds ? group.bounds.width() : 20,\n            height: group.bounds ? group.bounds.height() : 20\n          },\n          position: {\n            x: group.bounds ? group.bounds.x + group.bounds.width() / 2 : 0,\n            y: group.bounds ? group.bounds.y + group.bounds.height() / 2 : 0\n          }\n        };\n      }\n    );\n    this.outputGraph.edgeLabels = this.outputGraph.edges;\n    return this.outputGraph;\n  }\n\n  onDragStart(draggingNode: Node, $event: MouseEvent): void {\n    const nodeIndex = this.outputGraph.nodes.findIndex(foundNode => foundNode.id === draggingNode.id);\n    const node = this.internalGraph.nodes[nodeIndex];\n    if (!node) {\n      return;\n    }\n    this.draggingStart = { x: node.x - $event.x, y: node.y - $event.y };\n    node.fixed = 1;\n    this.settings.force.start();\n  }\n\n  onDrag(draggingNode: Node, $event: MouseEvent): void {\n    if (!draggingNode) {\n      return;\n    }\n    const nodeIndex = this.outputGraph.nodes.findIndex(foundNode => foundNode.id === draggingNode.id);\n    const node = this.internalGraph.nodes[nodeIndex];\n    if (!node) {\n      return;\n    }\n    node.x = this.draggingStart.x + $event.x;\n    node.y = this.draggingStart.y + $event.y;\n  }\n\n  onDragEnd(draggingNode: Node, $event: MouseEvent): void {\n    if (!draggingNode) {\n      return;\n    }\n    const nodeIndex = this.outputGraph.nodes.findIndex(foundNode => foundNode.id === draggingNode.id);\n    const node = this.internalGraph.nodes[nodeIndex];\n    if (!node) {\n      return;\n    }\n\n    node.fixed = 0;\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { Layout } from '../../models/layout.model';\nimport { DagreLayout } from './dagre';\nimport { DagreClusterLayout } from './dagreCluster';\nimport { DagreNodesOnlyLayout } from './dagreNodesOnly';\nimport { D3ForceDirectedLayout } from './d3ForceDirected';\nimport { ColaForceDirectedLayout } from './colaForceDirected';\n\nconst layouts = {\n  dagre: DagreLayout,\n  dagreCluster: DagreClusterLayout,\n  dagreNodesOnly: DagreNodesOnlyLayout,\n  d3ForceDirected: D3ForceDirectedLayout,\n  colaForceDirected: ColaForceDirectedLayout\n};\n\n@Injectable()\nexport class LayoutService {\n  getLayout(name: string): Layout {\n    if (layouts[name]) {\n      return new layouts[name]();\n    } else {\n      throw new Error(`Unknown layout type '${name}'`);\n    }\n  }\n}\n","// rename transition due to conflict with d3 transition\nimport { animate, style, transition as ngTransition, trigger } from '@angular/animations';\nimport {\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  Component,\n  ContentChild,\n  ElementRef,\n  EventEmitter,\n  HostListener,\n  Input,\n  OnDestroy,\n  OnInit,\n  Output,\n  QueryList,\n  TemplateRef,\n  ViewChild,\n  ViewChildren,\n  ViewEncapsulation,\n  NgZone,\n  ChangeDetectorRef,\n  OnChanges,\n  SimpleChanges\n} from '@angular/core';\nimport {\n  BaseChartComponent,\n  ChartComponent,\n  ColorHelper,\n  ViewDimensions,\n  calculateViewDimensions\n} from '@swimlane/ngx-charts';\nimport { select } from 'd3-selection';\nimport * as shape from 'd3-shape';\nimport * as ease from 'd3-ease';\nimport 'd3-transition';\nimport { Observable, Subscription, of } from 'rxjs';\nimport { first } from 'rxjs/operators';\nimport { identity, scale, smoothMatrix, toSVG, transform, translate } from 'transformation-matrix';\nimport { Layout } from '../models/layout.model';\nimport { LayoutService } from './layouts/layout.service';\nimport { Edge } from '../models/edge.model';\nimport { Node, ClusterNode } from '../models/node.model';\nimport { Graph } from '../models/graph.model';\nimport { id } from '../utils/id';\n\n/**\n * Matrix\n */\nexport interface Matrix {\n  a: number;\n  b: number;\n  c: number;\n  d: number;\n  e: number;\n  f: number;\n}\n\n@Component({\n  selector: 'ngx-graph',\n  styleUrls: ['./graph.component.scss'],\n  templateUrl: 'graph.component.html',\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class GraphComponent extends BaseChartComponent implements OnInit, OnChanges, OnDestroy, AfterViewInit {\n  @Input() legend: boolean = false;\n  @Input() nodes: Node[] = [];\n  @Input() clusters: ClusterNode[] = [];\n  @Input() links: Edge[] = [];\n  @Input() activeEntries: any[] = [];\n  @Input() curve: any;\n  @Input() draggingEnabled = true;\n  @Input() nodeHeight: number;\n  @Input() nodeMaxHeight: number;\n  @Input() nodeMinHeight: number;\n  @Input() nodeWidth: number;\n  @Input() nodeMinWidth: number;\n  @Input() nodeMaxWidth: number;\n  @Input() panningEnabled = true;\n  @Input() enableZoom = true;\n  @Input() zoomSpeed = 0.1;\n  @Input() minZoomLevel = 0.1;\n  @Input() maxZoomLevel = 4.0;\n  @Input() autoZoom = false;\n  @Input() panOnZoom = true;\n  @Input() animate? = false;\n  @Input() autoCenter = false;\n  @Input() update$: Observable<any>;\n  @Input() center$: Observable<any>;\n  @Input() zoomToFit$: Observable<any>;\n  @Input() panToNode$: Observable<any>;\n  @Input() layout: string | Layout;\n  @Input() layoutSettings: any;\n\n  @Output() activate: EventEmitter<any> = new EventEmitter();\n  @Output() deactivate: EventEmitter<any> = new EventEmitter();\n  @Output() zoomChange: EventEmitter<number> = new EventEmitter();\n\n  @ContentChild('linkTemplate') linkTemplate: TemplateRef<any>;\n  @ContentChild('nodeTemplate') nodeTemplate: TemplateRef<any>;\n  @ContentChild('clusterTemplate') clusterTemplate: TemplateRef<any>;\n  @ContentChild('defsTemplate') defsTemplate: TemplateRef<any>;\n\n  @ViewChild(ChartComponent, { read: ElementRef }) chart: ElementRef;\n  @ViewChildren('nodeElement') nodeElements: QueryList<ElementRef>;\n  @ViewChildren('linkElement') linkElements: QueryList<ElementRef>;\n\n  graphSubscription: Subscription = new Subscription();\n  subscriptions: Subscription[] = [];\n  colors: ColorHelper;\n  dims: ViewDimensions;\n  margin = [0, 0, 0, 0];\n  results = [];\n  seriesDomain: any;\n  transform: string;\n  legendOptions: any;\n  isPanning = false;\n  isDragging = false;\n  draggingNode: Node;\n  initialized = false;\n  graph: Graph;\n  graphDims: any = { width: 0, height: 0 };\n  _oldLinks: Edge[] = [];\n  oldNodes: Set<string> = new Set();\n  transformationMatrix: Matrix = identity();\n  _touchLastX = null;\n  _touchLastY = null;\n\n  constructor(\n    private el: ElementRef,\n    public zone: NgZone,\n    public cd: ChangeDetectorRef,\n    private layoutService: LayoutService\n  ) {\n    super(el, zone, cd);\n  }\n\n  @Input()\n  groupResultsBy: (node: any) => string = node => node.label;\n\n  /**\n   * Get the current zoom level\n   */\n  get zoomLevel() {\n    return this.transformationMatrix.a;\n  }\n\n  /**\n   * Set the current zoom level\n   */\n  @Input('zoomLevel')\n  set zoomLevel(level) {\n    this.zoomTo(Number(level));\n  }\n\n  /**\n   * Get the current `x` position of the graph\n   */\n  get panOffsetX() {\n    return this.transformationMatrix.e;\n  }\n\n  /**\n   * Set the current `x` position of the graph\n   */\n  @Input('panOffsetX')\n  set panOffsetX(x) {\n    this.panTo(Number(x), null);\n  }\n\n  /**\n   * Get the current `y` position of the graph\n   */\n  get panOffsetY() {\n    return this.transformationMatrix.f;\n  }\n\n  /**\n   * Set the current `y` position of the graph\n   */\n  @Input('panOffsetY')\n  set panOffsetY(y) {\n    this.panTo(null, Number(y));\n  }\n\n  /**\n   * Angular lifecycle event\n   *\n   *\n   * @memberOf GraphComponent\n   */\n  ngOnInit(): void {\n    if (this.update$) {\n      this.subscriptions.push(\n        this.update$.subscribe(() => {\n          this.update();\n        })\n      );\n    }\n\n    if (this.center$) {\n      this.subscriptions.push(\n        this.center$.subscribe(() => {\n          this.center();\n        })\n      );\n    }\n    if (this.zoomToFit$) {\n      this.subscriptions.push(\n        this.zoomToFit$.subscribe(() => {\n          this.zoomToFit();\n        })\n      );\n    }\n\n    if (this.panToNode$) {\n      this.subscriptions.push(\n        this.panToNode$.subscribe((nodeId: string) => {\n          this.panToNodeId(nodeId);\n        })\n      );\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    const { layout, layoutSettings, nodes, clusters, links } = changes;\n    this.setLayout(this.layout);\n    if (layoutSettings) {\n      this.setLayoutSettings(this.layoutSettings);\n    }\n    this.update();\n  }\n\n  setLayout(layout: string | Layout): void {\n    this.initialized = false;\n    if (!layout) {\n      layout = 'dagre';\n    }\n    if (typeof layout === 'string') {\n      this.layout = this.layoutService.getLayout(layout);\n      this.setLayoutSettings(this.layoutSettings);\n    }\n  }\n\n  setLayoutSettings(settings: any): void {\n    if (this.layout && typeof this.layout !== 'string') {\n      this.layout.settings = settings;\n      this.update();\n    }\n  }\n\n  /**\n   * Angular lifecycle event\n   *\n   *\n   * @memberOf GraphComponent\n   */\n  ngOnDestroy(): void {\n    super.ngOnDestroy();\n    for (const sub of this.subscriptions) {\n      sub.unsubscribe();\n    }\n    this.subscriptions = null;\n  }\n\n  /**\n   * Angular lifecycle event\n   *\n   *\n   * @memberOf GraphComponent\n   */\n  ngAfterViewInit(): void {\n    super.ngAfterViewInit();\n    setTimeout(() => this.update());\n  }\n\n  /**\n   * Base class update implementation for the dag graph\n   *\n   * @memberOf GraphComponent\n   */\n  update(): void {\n    super.update();\n    if (!this.curve) {\n      this.curve = shape.curveBundle.beta(1);\n    }\n\n    this.zone.run(() => {\n      this.dims = calculateViewDimensions({\n        width: this.width,\n        height: this.height,\n        margins: this.margin,\n        showLegend: this.legend\n      });\n\n      this.seriesDomain = this.getSeriesDomain();\n      this.setColors();\n      this.legendOptions = this.getLegendOptions();\n\n      this.createGraph();\n      this.updateTransform();\n      this.initialized = true;\n    });\n  }\n\n  /**\n   * Creates the dagre graph engine\n   *\n   * @memberOf GraphComponent\n   */\n  createGraph(): void {\n    this.graphSubscription.unsubscribe();\n    this.graphSubscription = new Subscription();\n    const initializeNode = n => {\n      if (!n.meta) {\n        n.meta = {};\n      }\n      if (!n.id) {\n        n.id = id();\n      }\n      if (!n.dimension) {\n        n.dimension = {\n          width: this.nodeWidth ? this.nodeWidth : 30,\n          height: this.nodeHeight ? this.nodeHeight : 30\n        };\n\n        n.meta.forceDimensions = false;\n      } else {\n        n.meta.forceDimensions = n.meta.forceDimensions === undefined ? true : n.meta.forceDimensions;\n      }\n      n.position = {\n        x: 0,\n        y: 0\n      };\n      n.data = n.data ? n.data : {};\n      return n;\n    };\n\n    this.graph = {\n      nodes: [...this.nodes].map(initializeNode),\n      clusters: [...(this.clusters || [])].map(initializeNode),\n      edges: [...this.links].map(e => {\n        if (!e.id) {\n          e.id = id();\n        }\n        return e;\n      })\n    };\n\n    requestAnimationFrame(() => this.draw());\n  }\n\n  /**\n   * Draws the graph using dagre layouts\n   *\n   *\n   * @memberOf GraphComponent\n   */\n  draw(): void {\n    if (!this.layout || typeof this.layout === 'string') {\n      return;\n    }\n    // Calc view dims for the nodes\n    this.applyNodeDimensions();\n\n    // Recalc the layout\n    const result = this.layout.run(this.graph);\n    const result$ = result instanceof Observable ? result : of(result);\n    this.graphSubscription.add(\n      result$.subscribe(graph => {\n        this.graph = graph;\n        this.tick();\n      })\n    );\n    result$.pipe(first(graph => graph.nodes.length > 0)).subscribe(() => this.applyNodeDimensions());\n  }\n\n  tick() {\n    // Transposes view options to the node\n    const oldNodes: Set<string> = new Set();\n\n    this.graph.nodes.map(n => {\n      n.transform = `translate(${n.position.x - n.dimension.width / 2 || 0}, ${n.position.y - n.dimension.height / 2 ||\n        0})`;\n      if (!n.data) {\n        n.data = {};\n      }\n      n.data.color = this.colors.getColor(this.groupResultsBy(n));\n      oldNodes.add(n.id);\n    });\n\n    // Prevent animations on new nodes\n    setTimeout(() => {\n      this.oldNodes = oldNodes;\n    }, 500);\n\n    (this.graph.clusters || []).map(n => {\n      n.transform = `translate(${n.position.x - n.dimension.width / 2 || 0}, ${n.position.y - n.dimension.height / 2 ||\n        0})`;\n      if (!n.data) {\n        n.data = {};\n      }\n      n.data.color = this.colors.getColor(this.groupResultsBy(n));\n    });\n\n    // Update the labels to the new positions\n    const newLinks = [];\n    for (const edgeLabelId in this.graph.edgeLabels) {\n      const edgeLabel = this.graph.edgeLabels[edgeLabelId];\n\n      const normKey = edgeLabelId.replace(/[^\\w-]*/g, '');\n\n      let oldLink = this._oldLinks.find(ol => `${ol.source}${ol.target}${ol.id}` === normKey);\n      let linkFromGraph = this.graph.edges.find(nl => `${nl.source}${nl.target}${nl.id}` === normKey);\n      \n      if (!oldLink) {\n        oldLink = linkFromGraph || edgeLabel;\n      } else if (\n        oldLink.data && \n        linkFromGraph && linkFromGraph.data && \n        JSON.stringify(oldLink.data) !== JSON.stringify(linkFromGraph.data)) { // Compare old link to new link and replace if not equal      \n        oldLink.data = linkFromGraph.data \n      }\n\n      oldLink.oldLine = oldLink.line;\n\n      const points = edgeLabel.points;\n      const line = this.generateLine(points);\n\n      const newLink = Object.assign({}, oldLink);\n      newLink.line = line;\n      newLink.points = points;\n\n      if (points.length % 2 === 1) {\n        newLink.midPoint = points[Math.floor(points.length / 2)];\n      } else {\n        const first = points[points.length / 2];\n        const second = points[points.length / 2 - 1];\n        newLink.midPoint = {\n          x: (first.x + second.x) / 2,\n          y: (first.y + second.y) / 2\n        };\n      }\n\n      const textPos = points[Math.floor(points.length / 2)];\n      if (textPos) {\n        newLink.textTransform = `translate(${textPos.x || 0},${textPos.y || 0})`;\n      }\n\n      newLink.textAngle = 0;\n      if (!newLink.oldLine) {\n        newLink.oldLine = newLink.line;\n      }\n\n      this.calcDominantBaseline(newLink);\n      newLinks.push(newLink);\n    }\n\n    this.graph.edges = newLinks;\n\n    // Map the old links for animations\n    if (this.graph.edges) {\n      this._oldLinks = this.graph.edges.map(l => {\n        const newL = Object.assign({}, l);\n        newL.oldLine = l.line;\n        return newL;\n      });\n    }\n\n    // Calculate the height/width total\n    this.graphDims.width = Math.max(...this.graph.nodes.map(n => n.position.x + n.dimension.width));\n    this.graphDims.height = Math.max(...this.graph.nodes.map(n => n.position.y + n.dimension.height));\n\n    if (this.autoZoom) {\n      this.zoomToFit();\n    }\n\n    if (this.autoCenter) {\n      // Auto-center when rendering\n      this.center();\n    }\n\n    requestAnimationFrame(() => this.redrawLines());\n    this.cd.markForCheck();\n  }\n\n  /**\n   * Measures the node element and applies the dimensions\n   *\n   * @memberOf GraphComponent\n   */\n  applyNodeDimensions(): void {\n    if (this.nodeElements && this.nodeElements.length) {\n      this.nodeElements.map(elem => {\n        const nativeElement = elem.nativeElement;\n        const node = this.graph.nodes.find(n => n.id === nativeElement.id);\n\n        // calculate the height\n        let dims;\n        try {\n          dims = nativeElement.getBBox();\n        } catch (ex) {\n          // Skip drawing if element is not displayed - Firefox would throw an error here\n          return;\n        }\n        if (this.nodeHeight) {          \n          node.dimension.height = node.dimension.height && node.meta.forceDimensions ? node.dimension.height : this.nodeHeight;\n        } else {\n          node.dimension.height = node.dimension.height && node.meta.forceDimensions ? node.dimension.height : dims.height;\n        }\n\n        if (this.nodeMaxHeight) {\n          node.dimension.height = Math.max(node.dimension.height, this.nodeMaxHeight);\n        }\n        if (this.nodeMinHeight) {\n          node.dimension.height = Math.min(node.dimension.height, this.nodeMinHeight);\n        }\n\n        if (this.nodeWidth) {\n          node.dimension.width =  node.dimension.width && node.meta.forceDimensions ? node.dimension.width : this.nodeWidth;\n        } else {\n          // calculate the width\n          if (nativeElement.getElementsByTagName('text').length) {\n            let maxTextDims;\n            try {\n              for (const textElem of nativeElement.getElementsByTagName('text')) {\n                const currentBBox = textElem.getBBox();\n                if (!maxTextDims) {\n                  maxTextDims = currentBBox;\n                } else {\n                  if (currentBBox.width > maxTextDims.width) {\n                    maxTextDims.width = currentBBox.width;\n                  }\n                  if (currentBBox.height > maxTextDims.height) {\n                    maxTextDims.height = currentBBox.height;\n                  }\n                }\n              }\n            } catch (ex) {\n              // Skip drawing if element is not displayed - Firefox would throw an error here\n              return;\n            }\n            node.dimension.width = node.dimension.width && node.meta.forceDimensions ? node.dimension.width : maxTextDims.width + 20;\n          } else {\n            node.dimension.width = node.dimension.width && node.meta.forceDimensions ? node.dimension.width : dims.width;\n          }\n        }\n\n        if (this.nodeMaxWidth) {\n          node.dimension.width = Math.max(node.dimension.width, this.nodeMaxWidth);\n        }\n        if (this.nodeMinWidth) {\n          node.dimension.width = Math.min(node.dimension.width, this.nodeMinWidth);\n        }\n      });\n    }\n  }\n\n  /**\n   * Redraws the lines when dragged or viewport updated\n   *\n   * @memberOf GraphComponent\n   */\n  redrawLines(_animate = this.animate): void {\n    this.linkElements.map(linkEl => {\n      const edge = this.graph.edges.find(lin => lin.id === linkEl.nativeElement.id);\n\n      if (edge) {\n        const linkSelection = select(linkEl.nativeElement).select('.line');\n        linkSelection\n          .attr('d', edge.oldLine)\n          .transition()\n          .ease(ease.easeSinInOut)\n          .duration(_animate ? 500 : 0)\n          .attr('d', edge.line);\n\n        const textPathSelection = select(this.chartElement.nativeElement).select(`#${edge.id}`);\n        textPathSelection\n          .attr('d', edge.oldTextPath)\n          .transition()\n          .ease(ease.easeSinInOut)\n          .duration(_animate ? 500 : 0)\n          .attr('d', edge.textPath);\n      }\n    });\n  }\n\n  /**\n   * Calculate the text directions / flipping\n   *\n   * @memberOf GraphComponent\n   */\n  calcDominantBaseline(link): void {\n    const firstPoint = link.points[0];\n    const lastPoint = link.points[link.points.length - 1];\n    link.oldTextPath = link.textPath;\n\n    if (lastPoint.x < firstPoint.x) {\n      link.dominantBaseline = 'text-before-edge';\n\n      // reverse text path for when its flipped upside down\n      link.textPath = this.generateLine([...link.points].reverse());\n    } else {\n      link.dominantBaseline = 'text-after-edge';\n      link.textPath = link.line;\n    }\n  }\n\n  /**\n   * Generate the new line path\n   *\n   * @memberOf GraphComponent\n   */\n  generateLine(points): any {\n    const lineFunction = shape\n      .line<any>()\n      .x(d => d.x)\n      .y(d => d.y)\n      .curve(this.curve);\n    return lineFunction(points);\n  }\n\n  /**\n   * Zoom was invoked from event\n   *\n   * @memberOf GraphComponent\n   */\n  onZoom($event: MouseEvent, direction): void {\n    const zoomFactor = 1 + (direction === 'in' ? this.zoomSpeed : -this.zoomSpeed);\n\n    // Check that zooming wouldn't put us out of bounds\n    const newZoomLevel = this.zoomLevel * zoomFactor;\n    if (newZoomLevel <= this.minZoomLevel || newZoomLevel >= this.maxZoomLevel) {\n      return;\n    }\n\n    // Check if zooming is enabled or not\n    if (!this.enableZoom) {\n      return;\n    }\n\n    if (this.panOnZoom === true && $event) {\n      // Absolute mouse X/Y on the screen\n      const mouseX = $event.clientX;\n      const mouseY = $event.clientY;\n\n      // Transform the mouse X/Y into a SVG X/Y\n      const svg = this.chart.nativeElement.querySelector('svg');\n      const svgGroup = svg.querySelector('g.chart');\n\n      const point = svg.createSVGPoint();\n      point.x = mouseX;\n      point.y = mouseY;\n      const svgPoint = point.matrixTransform(svgGroup.getScreenCTM().inverse());\n\n      // Panzoom\n      this.pan(svgPoint.x, svgPoint.y, true);\n      this.zoom(zoomFactor);\n      this.pan(-svgPoint.x, -svgPoint.y, true);\n    } else {\n      this.zoom(zoomFactor);\n    }\n  }\n\n  /**\n   * Pan by x/y\n   *\n   * @param x\n   * @param y\n   */\n  pan(x: number, y: number, ignoreZoomLevel: boolean = false): void {\n    const zoomLevel = ignoreZoomLevel ? 1 : this.zoomLevel;\n    this.transformationMatrix = transform(this.transformationMatrix, translate(x / zoomLevel, y / zoomLevel));\n\n    this.updateTransform();\n  }\n\n  /**\n   * Pan to a fixed x/y\n   *\n   */\n  panTo(x: number, y: number): void {\n    if (x === null || x === undefined || isNaN(x) || y === null || y === undefined || isNaN(y)) {\n      return;\n    }\n\n    const panX = -this.panOffsetX - x * this.zoomLevel + this.dims.width / 2;\n    const panY = -this.panOffsetY - y * this.zoomLevel + this.dims.height / 2;\n\n    this.transformationMatrix = transform(\n      this.transformationMatrix,\n      translate(panX / this.zoomLevel, panY / this.zoomLevel)\n    );\n\n    this.updateTransform();\n  }\n\n  /**\n   * Zoom by a factor\n   *\n   */\n  zoom(factor: number): void {\n    this.transformationMatrix = transform(this.transformationMatrix, scale(factor, factor));\n    this.zoomChange.emit(this.zoomLevel);\n    this.updateTransform();\n  }\n\n  /**\n   * Zoom to a fixed level\n   *\n   */\n  zoomTo(level: number): void {\n    this.transformationMatrix.a = isNaN(level) ? this.transformationMatrix.a : Number(level);\n    this.transformationMatrix.d = isNaN(level) ? this.transformationMatrix.d : Number(level);\n    this.zoomChange.emit(this.zoomLevel);\n    this.updateTransform();\n    this.update();\n  }\n\n  /**\n   * Pan was invoked from event\n   *\n   * @memberOf GraphComponent\n   */\n  onPan(event): void {\n    this.pan(event.movementX, event.movementY);\n  }\n\n  /**\n   * Drag was invoked from an event\n   *\n   * @memberOf GraphComponent\n   */\n  onDrag(event): void {\n    if (!this.draggingEnabled) {\n      return;\n    }\n    const node = this.draggingNode;\n    if (this.layout && typeof this.layout !== 'string' && this.layout.onDrag) {\n      this.layout.onDrag(node, event);\n    }\n\n    node.position.x += event.movementX / this.zoomLevel;\n    node.position.y += event.movementY / this.zoomLevel;\n\n    // move the node\n    const x = node.position.x - node.dimension.width / 2;\n    const y = node.position.y - node.dimension.height / 2;\n    node.transform = `translate(${x}, ${y})`;\n\n    for (const link of this.graph.edges) {\n      if (\n        link.target === node.id ||\n        link.source === node.id ||\n        (link.target as any).id === node.id ||\n        (link.source as any).id === node.id\n      ) {\n        if (this.layout && typeof this.layout !== 'string') {\n          const result = this.layout.updateEdge(this.graph, link);\n          const result$ = result instanceof Observable ? result : of(result);\n          this.graphSubscription.add(\n            result$.subscribe(graph => {\n              this.graph = graph;\n              this.redrawEdge(link);\n            })\n          );\n        }\n      }\n    }\n\n    this.redrawLines(false);\n  }\n\n  redrawEdge(edge: Edge) {\n    const line = this.generateLine(edge.points);\n    this.calcDominantBaseline(edge);\n    edge.oldLine = edge.line;\n    edge.line = line;\n  }\n\n  /**\n   * Update the entire view for the new pan position\n   *\n   *\n   * @memberOf GraphComponent\n   */\n  updateTransform(): void {\n    this.transform = toSVG(smoothMatrix(this.transformationMatrix, 100));\n  }\n\n  /**\n   * Node was clicked\n   *\n   *\n   * @memberOf GraphComponent\n   */\n  onClick(event): void {\n    this.select.emit(event);\n  }\n\n  /**\n   * Node was focused\n   *\n   *\n   * @memberOf GraphComponent\n   */\n  onActivate(event): void {\n    if (this.activeEntries.indexOf(event) > -1) {\n      return;\n    }\n    this.activeEntries = [event, ...this.activeEntries];\n    this.activate.emit({ value: event, entries: this.activeEntries });\n  }\n\n  /**\n   * Node was defocused\n   *\n   * @memberOf GraphComponent\n   */\n  onDeactivate(event): void {\n    const idx = this.activeEntries.indexOf(event);\n\n    this.activeEntries.splice(idx, 1);\n    this.activeEntries = [...this.activeEntries];\n\n    this.deactivate.emit({ value: event, entries: this.activeEntries });\n  }\n\n  /**\n   * Get the domain series for the nodes\n   *\n   * @memberOf GraphComponent\n   */\n  getSeriesDomain(): any[] {\n    return this.nodes\n      .map(d => this.groupResultsBy(d))\n      .reduce((nodes: string[], node): any[] => (nodes.indexOf(node) !== -1 ? nodes : nodes.concat([node])), [])\n      .sort();\n  }\n\n  /**\n   * Tracking for the link\n   *\n   *\n   * @memberOf GraphComponent\n   */\n  trackLinkBy(index, link): any {\n    return link.id;\n  }\n\n  /**\n   * Tracking for the node\n   *\n   *\n   * @memberOf GraphComponent\n   */\n  trackNodeBy(index, node): any {\n    return node.id;\n  }\n\n  /**\n   * Sets the colors the nodes\n   *\n   *\n   * @memberOf GraphComponent\n   */\n  setColors(): void {\n    this.colors = new ColorHelper(this.scheme, 'ordinal', this.seriesDomain, this.customColors);\n  }\n\n  /**\n   * Gets the legend options\n   *\n   * @memberOf GraphComponent\n   */\n  getLegendOptions(): any {\n    return {\n      scaleType: 'ordinal',\n      domain: this.seriesDomain,\n      colors: this.colors\n    };\n  }\n\n  /**\n   * On mouse move event, used for panning and dragging.\n   *\n   * @memberOf GraphComponent\n   */\n  @HostListener('document:mousemove', ['$event'])\n  onMouseMove($event: MouseEvent): void {\n    if (this.isPanning && this.panningEnabled) {\n      this.onPan($event);\n    } else if (this.isDragging && this.draggingEnabled) {\n      this.onDrag($event);\n    }\n  }\n\n  /**\n   * On touch start event to enable panning.\n   *\n   * @memberOf GraphComponent\n   */\n  onTouchStart(event) {\n    this._touchLastX = event.changedTouches[0].clientX;\n    this._touchLastY = event.changedTouches[0].clientY;\n\n    this.isPanning = true;\n  }\n\n  /**\n   * On touch move event, used for panning.\n   *\n   */\n  @HostListener('document:touchmove', ['$event'])\n  onTouchMove($event: any): void {\n    if (this.isPanning && this.panningEnabled) {\n      const clientX = $event.changedTouches[0].clientX;\n      const clientY = $event.changedTouches[0].clientY;\n      const movementX = clientX - this._touchLastX;\n      const movementY = clientY - this._touchLastY;\n      this._touchLastX = clientX;\n      this._touchLastY = clientY;\n\n      this.pan(movementX, movementY);\n    }\n  }\n\n  /**\n   * On touch end event to disable panning.\n   *\n   * @memberOf GraphComponent\n   */\n  onTouchEnd(event) {\n    this.isPanning = false;\n  }\n\n  /**\n   * On mouse up event to disable panning/dragging.\n   *\n   * @memberOf GraphComponent\n   */\n  @HostListener('document:mouseup')\n  onMouseUp(event: MouseEvent): void {\n    this.isDragging = false;\n    this.isPanning = false;\n    if (this.layout && typeof this.layout !== 'string' && this.layout.onDragEnd) {\n      this.layout.onDragEnd(this.draggingNode, event);\n    }\n  }\n\n  /**\n   * On node mouse down to kick off dragging\n   *\n   * @memberOf GraphComponent\n   */\n  onNodeMouseDown(event: MouseEvent, node: any): void {\n    if (!this.draggingEnabled) {\n      return;\n    }\n    this.isDragging = true;\n    this.draggingNode = node;\n\n    if (this.layout && typeof this.layout !== 'string' && this.layout.onDragStart) {\n      this.layout.onDragStart(node, event);\n    }\n  }\n\n  /**\n   * Center the graph in the viewport\n   */\n  center(): void {\n    this.panTo(this.graphDims.width / 2, this.graphDims.height / 2);\n  }\n\n  /**\n   * Zooms to fit the entier graph\n   */\n  zoomToFit(): void {\n    const heightZoom = this.dims.height / this.graphDims.height;\n    const widthZoom = this.dims.width / this.graphDims.width;\n    const zoomLevel = Math.min(heightZoom, widthZoom, 1);\n\n    if (zoomLevel <= this.minZoomLevel || zoomLevel >= this.maxZoomLevel) {\n      return;\n    }\n    \n    if (zoomLevel !== this.zoomLevel) {\n      this.zoomLevel = zoomLevel;\n      this.updateTransform();\n      this.zoomChange.emit(this.zoomLevel);\n    }\n  }\n\n  /**\n   * Pans to the node\n   * @param nodeId \n   */\n  panToNodeId(nodeId: string): void {\n    const node = this.nodes.find(n => n.id === nodeId);\n    if (!node) {\n      return;\n    }\n\n    this.panTo(node.position.x, node.position.y);\n  }\n}\n","import { Directive, Output, HostListener, EventEmitter } from '@angular/core';\n\n/**\n * Mousewheel directive\n * https://github.com/SodhanaLibrary/angular2-examples/blob/master/app/mouseWheelDirective/mousewheel.directive.ts\n *\n * @export\n */\n@Directive({ selector: '[mouseWheel]' })\nexport class MouseWheelDirective {\n  @Output()\n  mouseWheelUp = new EventEmitter();\n  @Output()\n  mouseWheelDown = new EventEmitter();\n\n  @HostListener('mousewheel', ['$event'])\n  onMouseWheelChrome(event: any): void {\n    this.mouseWheelFunc(event);\n  }\n\n  @HostListener('DOMMouseScroll', ['$event'])\n  onMouseWheelFirefox(event: any): void {\n    this.mouseWheelFunc(event);\n  }\n\n  @HostListener('onmousewheel', ['$event'])\n  onMouseWheelIE(event: any): void {\n    this.mouseWheelFunc(event);\n  }\n\n  mouseWheelFunc(event: any): void {\n    if (window.event) {\n      event = window.event;\n    }\n\n    const delta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));\n    if (delta > 0) {\n      this.mouseWheelUp.emit(event);\n    } else if (delta < 0) {\n      this.mouseWheelDown.emit(event);\n    }\n\n    // for IE\n    event.returnValue = false;\n\n    // for Chrome and Firefox\n    if (event.preventDefault) {\n      event.preventDefault();\n    }\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { GraphComponent } from './graph.component';\nimport { ChartCommonModule } from '@swimlane/ngx-charts';\nimport { MouseWheelDirective } from './mouse-wheel.directive';\nimport { LayoutService } from './layouts/layout.service';\nexport { GraphComponent };\n\n@NgModule({\n  imports: [ChartCommonModule],\n  declarations: [GraphComponent, MouseWheelDirective],\n  exports: [GraphComponent, MouseWheelDirective],\n  providers: [LayoutService]\n})\nexport class GraphModule {}\n","import { NgModule } from '@angular/core';\nimport { GraphModule } from './graph/graph.module';\nimport { NgxChartsModule } from '@swimlane/ngx-charts';\n\nexport * from './models/index';\nexport * from './graph/graph.component';\n\n@NgModule({\n  imports: [NgxChartsModule],\n  exports: [GraphModule]\n})\nexport class NgxGraphModule {}\n"]}